#!/usr/bin/env python3
"""
Generate C++ header from JSON coefficients.
This creates a clean separation: Python computes, JSON stores, C++ uses.
"""

import json
import sys

def generate_header_from_json(json_path='coefficients.json', output_path='InverseCumulativeNormal.h'):
    """Generate C++ header from JSON coefficients"""
    
    # Read coefficients from JSON
    with open(json_path, 'r') as f:
        config = json.load(f)
    
    central = config['central_region']
    tail = config['tail_region']
    params = config['parameters']
    metadata = config['metadata']
    
    # Format coefficient arrays
    def format_array(coeffs):
        return ',\n        '.join(f'{c:.18e}' for c in coeffs)
    
    # Generate header
    header = f'''#pragma once
/*
 * Auto-generated from JSON coefficients
 * Generated: {metadata['generated_at']}
 * 
 * Central region: degree ({central['degree_m']}, {central['degree_n']})
 *   Max error: {central['max_error']:.6e}
 *   Mean error: {central['mean_error']:.6e}
 * 
 * Tail region: degree ({tail['degree_p']}, {tail['degree_q']})
 *   Max error: {tail['max_error']:.6e}
 *   Mean error: {tail['mean_error']:.6e}
 * 
 * DO NOT EDIT THIS FILE MANUALLY
 * Regenerate using: python3 export_coefficients.py && python3 json_to_header.py
 */

#include <cmath>
#include <cstddef>
#include <limits>
#include <algorithm>

using namespace std;

namespace quant {{

class InverseCumulativeNormal {{
  public:
    explicit InverseCumulativeNormal(double average = 0.0, double sigma = 1.0)
    : average_(average), sigma_(sigma) {{}}

    inline double operator()(double x) const {{
        return average_ + sigma_ * standard_value(x);
    }}

    inline void operator()(const double* in, double* out, size_t n) const {{
        for (size_t i = 0; i < n; ++i) {{
            out[i] = average_ + sigma_ * standard_value(in[i]);
        }}
    }}

    static inline double standard_value(double x) {{
        if (x <= 0.0) return -numeric_limits<double>::infinity();
        if (x >= 1.0) return  numeric_limits<double>::infinity();

        double z;
        if (x < x_low_ || x > x_high_) {{
            z = tail_value(x);
        }} else {{
            z = central_value(x);
        }}
        
        z = halley_refine(z, x);
        z = halley_refine(z, x);
        
        return z;
    }}

  private:
    static inline double central_value(double x) {{
        const double u = x - 0.5;
        const double r = u * u;
        
        double P = CENTRAL_A[CENTRAL_M];
        for (int i = CENTRAL_M - 1; i >= 0; --i) {{
            P = P * r + CENTRAL_A[i];
        }}
        
        double Q = CENTRAL_B[CENTRAL_N];
        for (int i = CENTRAL_N - 1; i >= 0; --i) {{
            Q = Q * r + CENTRAL_B[i];
        }}
        
        return u * P / Q;
    }}

    static inline double tail_value(double x) {{
        const double m = min(x, 1.0 - x);
        const double t = sqrt(-2.0 * log(m));
        const double s = (x < 0.5) ? -1.0 : 1.0;
        
        double C = TAIL_C[TAIL_P];
        for (int i = TAIL_P - 1; i >= 0; --i) {{
            C = C * t + TAIL_C[i];
        }}
        
        double D = TAIL_D[TAIL_Q];
        for (int i = TAIL_Q - 1; i >= 0; --i) {{
            D = D * t + TAIL_D[i];
        }}
        
        return s * C / D;
    }}

    static inline double halley_refine(double z, double x) {{
        const double r = compute_stable_residual(z, x);
        const double denom = 1.0 - 0.5 * z * r;
        
        if (abs(denom) < numeric_limits<double>::min()) {{
            return z - copysign(numeric_limits<double>::infinity(), r);
        }}
        
        return z - r / denom;
    }}

    static inline double compute_stable_residual(double z, double x) {{
        constexpr double TAIL_THRESHOLD = 1e-8;
        const double p = phi(z);
        
        if (x >= TAIL_THRESHOLD && x <= 1.0 - TAIL_THRESHOLD) {{
            const double f = Phi(z);
            return (f - x) / max(p, numeric_limits<double>::min());
        }}
        
        if (x < 0.5) {{
            const double y = x;
            const double log_q = log(Q(-z));
            const double log_y = log(y);
            return y * expm1(log_q - log_y) / max(p, numeric_limits<double>::min());
        }} else {{
            const double y = 1.0 - x;
            const double log_q = log(Q(z));
            const double log_y = log(y);
            return -y * expm1(log_q - log_y) / max(p, numeric_limits<double>::min());
        }}
    }}

    static inline double phi(double z) {{
        constexpr double INV_SQRT_2PI = 0.398942280401432677939946059934381868475858631164934657;
        return INV_SQRT_2PI * exp(-0.5 * z * z);
    }}

    static inline double Phi(double z) {{
        constexpr double INV_SQRT_2 = 0.707106781186547524400844362104849039284835937688474036588;
        return 0.5 * erfc(-z * INV_SQRT_2);
    }}

    static inline double Q(double z) {{
        constexpr double INV_SQRT_2 = 0.707106781186547524400844362104849039284835937688474036588;
        return 0.5 * erfc(z * INV_SQRT_2);
    }}

    // ===== COEFFICIENTS FROM JSON =====
    
    // Central region: degree ({central['degree_m']}, {central['degree_n']})
    static constexpr int CENTRAL_M = {central['degree_m']};
    static constexpr double CENTRAL_A[{len(central['coefficients_a'])}] = {{
        {format_array(central['coefficients_a'])}
    }};

    static constexpr int CENTRAL_N = {central['degree_n']};
    static constexpr double CENTRAL_B[{len(central['coefficients_b'])}] = {{
        {format_array(central['coefficients_b'])}
    }};

    // Tail region: degree ({tail['degree_p']}, {tail['degree_q']})
    static constexpr int TAIL_P = {tail['degree_p']};
    static constexpr double TAIL_C[{len(tail['coefficients_c'])}] = {{
        {format_array(tail['coefficients_c'])}
    }};

    static constexpr int TAIL_Q = {tail['degree_q']};
    static constexpr double TAIL_D[{len(tail['coefficients_d'])}] = {{
        {format_array(tail['coefficients_d'])}
    }};

    // ===== END COEFFICIENTS =====

    double average_, sigma_;
    static constexpr double x_low_  = {params['x_low']};
    static constexpr double x_high_ = {params['x_high']};
}};

}} // namespace quant
'''
    
    with open(output_path, 'w') as f:
        f.write(header)
    
    print(f"âœ… Generated C++ header: {output_path}")
    print(f"   Source: {json_path}")
    print(f"   Central: ({central['degree_m']},{central['degree_n']}), Tail: ({tail['degree_p']},{tail['degree_q']})")

if __name__ == '__main__':
    json_file = sys.argv[1] if len(sys.argv) > 1 else 'coefficients.json'
    output_file = sys.argv[2] if len(sys.argv) > 2 else 'InverseCumulativeNormal_from_json.h'
    generate_header_from_json(json_file, output_file)
