#pragma once
/*
 * Auto-generated from JSON coefficients
 * Generated: 2025-11-09T13:19:40.842903
 * 
 * Central region: degree (6, 6)
 *   Max error: 1.391751e-05
 *   Mean error: 1.212946e-06
 * 
 * Tail region: degree (8, 8)
 *   Max error: 5.577336e-06
 *   Mean error: 1.435348e-06
 * 
 * DO NOT EDIT THIS FILE MANUALLY
 * Regenerate using: python3 export_coefficients.py && python3 json_to_header.py
 */

#include <cmath>
#include <cstddef>
#include <limits>
#include <algorithm>

using namespace std;

namespace quant {

class InverseCumulativeNormal {
  public:
    explicit InverseCumulativeNormal(double average = 0.0, double sigma = 1.0)
    : average_(average), sigma_(sigma) {}

    inline double operator()(double x) const {
        return average_ + sigma_ * standard_value(x);
    }

    inline void operator()(const double* in, double* out, size_t n) const {
        for (size_t i = 0; i < n; ++i) {
            out[i] = average_ + sigma_ * standard_value(in[i]);
        }
    }

    static inline double standard_value(double x) {
        if (x <= 0.0) return -numeric_limits<double>::infinity();
        if (x >= 1.0) return  numeric_limits<double>::infinity();

        double z;
        if (x < x_low_ || x > x_high_) {
            z = tail_value(x);
        } else {
            z = central_value(x);
        }
        
        z = halley_refine(z, x);
        z = halley_refine(z, x);
        
        return z;
    }

  private:
    static inline double central_value(double x) {
        const double u = x - 0.5;
        const double r = u * u;
        
        double P = CENTRAL_A[CENTRAL_M];
        for (int i = CENTRAL_M - 1; i >= 0; --i) {
            P = P * r + CENTRAL_A[i];
        }
        
        double Q = CENTRAL_B[CENTRAL_N];
        for (int i = CENTRAL_N - 1; i >= 0; --i) {
            Q = Q * r + CENTRAL_B[i];
        }
        
        return u * P / Q;
    }

    static inline double tail_value(double x) {
        const double m = min(x, 1.0 - x);
        const double t = sqrt(-2.0 * log(m));
        const double s = (x < 0.5) ? -1.0 : 1.0;
        
        double C = TAIL_C[TAIL_P];
        for (int i = TAIL_P - 1; i >= 0; --i) {
            C = C * t + TAIL_C[i];
        }
        
        double D = TAIL_D[TAIL_Q];
        for (int i = TAIL_Q - 1; i >= 0; --i) {
            D = D * t + TAIL_D[i];
        }
        
        return s * C / D;
    }

    static inline double halley_refine(double z, double x) {
        const double r = compute_stable_residual(z, x);
        const double denom = 1.0 - 0.5 * z * r;
        
        if (abs(denom) < numeric_limits<double>::min()) {
            return z - copysign(numeric_limits<double>::infinity(), r);
        }
        
        return z - r / denom;
    }

    static inline double compute_stable_residual(double z, double x) {
        constexpr double TAIL_THRESHOLD = 1e-8;
        const double p = phi(z);
        
        if (x >= TAIL_THRESHOLD && x <= 1.0 - TAIL_THRESHOLD) {
            const double f = Phi(z);
            return (f - x) / max(p, numeric_limits<double>::min());
        }
        
        if (x < 0.5) {
            const double y = x;
            const double log_q = log(Q(-z));
            const double log_y = log(y);
            return y * expm1(log_q - log_y) / max(p, numeric_limits<double>::min());
        } else {
            const double y = 1.0 - x;
            const double log_q = log(Q(z));
            const double log_y = log(y);
            return -y * expm1(log_q - log_y) / max(p, numeric_limits<double>::min());
        }
    }

    static inline double phi(double z) {
        constexpr double INV_SQRT_2PI = 0.398942280401432677939946059934381868475858631164934657;
        return INV_SQRT_2PI * exp(-0.5 * z * z);
    }

    static inline double Phi(double z) {
        constexpr double INV_SQRT_2 = 0.707106781186547524400844362104849039284835937688474036588;
        return 0.5 * erfc(-z * INV_SQRT_2);
    }

    static inline double Q(double z) {
        constexpr double INV_SQRT_2 = 0.707106781186547524400844362104849039284835937688474036588;
        return 0.5 * erfc(z * INV_SQRT_2);
    }

    // ===== COEFFICIENTS FROM JSON =====
    
    // Central region: degree (6, 6)
    static constexpr int CENTRAL_M = 6;
    static constexpr double CENTRAL_A[7] = {
        2.506632854490859597e+00,
        -1.422236589581395627e+01,
        1.443940992231501674e+01,
        1.125587850479905505e+01,
        6.235951994187552749e+00,
        5.360984236954892346e+00,
        1.548292849870007259e+00
    };

    static constexpr int CENTRAL_N = 6;
    static constexpr double CENTRAL_B[7] = {
        1.000000000000000000e+00,
        -6.720907494037536622e+00,
        1.049064736555859056e+01,
        2.770230007345471090e+00,
        -1.235906088649952661e+00,
        -4.071878664464104070e+00,
        9.604872394541887903e-01
    };

    // Tail region: degree (8, 8)
    static constexpr int TAIL_P = 8;
    static constexpr double TAIL_C[9] = {
        -1.858032981648610305e+00,
        2.588225612061147984e+00,
        -9.458143568290986458e-01,
        9.635777642798729059e-02,
        -1.093361782182804796e-02,
        1.151095845392377612e-03,
        -7.697710330474194962e-05,
        7.091999104160253720e-06,
        -1.637883410810526020e-06
    };

    static constexpr int TAIL_Q = 8;
    static constexpr double TAIL_D[9] = {
        1.000000000000000000e+00,
        -3.643167149463678034e-01,
        -5.972810066061043366e-02,
        1.917808555073034077e-02,
        -2.882548470945496110e-03,
        2.860918773389828037e-04,
        -1.430583773078767941e-05,
        -9.340241703516925078e-07,
        -9.914343700468198135e-09
    };

    // ===== END COEFFICIENTS =====

    double average_, sigma_;
    static constexpr double x_low_  = 0.02425;
    static constexpr double x_high_ = 0.97575;
};

} // namespace quant
